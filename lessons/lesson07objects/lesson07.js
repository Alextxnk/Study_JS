'use strict';


// объекты - фундаментаная тема в javascript 

// объект - это коллекция данных, структура, которая используется для хранения любых данных 
// тоесть объект может соержать любой тип данных 

// первый способ создания объекта 
let car = {
   model: 'mazda', // добавляем свойства в объект
   year: 2006,
   turbocharging: true,
   specifications: [],
   style: {
      color: 'blue'
   }
}; // присвоили переменной значение, которое является объектом 

// model и year - это именя свойств, еще их называют ключи 
// 'mazda' и 2006 - это значения 

// после того, как объект создан можно добавлять и изменять его свойства 

// второй способ создания объекта
// создание объекта с помощью конструктора 
// тему конструкторов пройдем позже 

let obj = new Object(); 

// car.turbocharging = true; // добавили в объект новое свойство 

// console.log(car);
// console.log(car.model); // можем обращаться к каждому свойству индивидуально, 
// сначала обращаемся к объекту, далее через точку к его свойству 

obj.color = 'black'; // в объект, созданный констрктором можно также добавлять свойства 
// и потом обращаться к ним

console.log(obj); 

// car.style = obj; // добавляем вложенный объект в объект car 

// console.log(car);

// console.log(car.style === obj); // true 
// на самом дела car.style - это ссылка на объект, т.к. копировать объекты ресурсозатратно, 
// javascript скопировал ссылку на объект 

// car.style.color = 'red';
// console.log(obj);



// объекты могу содержать свойства с любым типом данных 

// помимо этого объекты могут содержать функции 

// запись function expression в объект 
car.ride = function(speed) {
   console.log('Машина едет со скоростью ' + speed + ' км/ч');
};
car.ride(150); // вызов метода 



// запись function declaration в объект 
function stop() {
   console.log('Машина стоит, скорость о км/ч');
}
car.stop = stop; // добавили в объект функцию 
car.stop(); // вызвали функцию 


console.log(car);

// обращаться к свойствам объекта можно еще с помощью альтернативного синтаксиса 
console.log(car.model); // обычный способ 
console.log(car['model']); // альтернативный способ

car['best place'] = 'city'; // таким же способом можно изменять или добавлять новые свойства 
// тут можно писать полноценные строки с пробелами 

console.log(car);

// также значения могут приходить из переменных 
let titleTrans = 'Коробка передач';
let bodyTrans = 'Автоматическая коробка передач'; 

car[titleTrans] = bodyTrans; // в таком случае в кавычки закрывать не нужно, мы вставляем переменные 



// массивы 

// массив в jabascript - это объект в котором ключи заполняются jabascript автоматически 

let  arr = [1, 2, 3, 4, 5];

// массив так же как и объект может содержать любые типы данных и еще объекты и массивы 

console.log(arr);

// отличаются объекты от массивов тем то что ключи в массивах заполняются автоматически 
// и подставляется порядковый номер с индексом
// начинается индекс в массивах с нуля 

// обращаться к элементам можно с помощью квадратных скобок 

// по индексу можно не только получать элемент, но и изменять его 
arr[0] = 'cat';
console.log(arr[0]);

// у массива есть свойство length, это свойство хранит количество элементов в массиве 
console.log(arr.length);


// один из способов добавить элемент в конец массива 

// длина массива всегда будет на 1 больше его индекса  
arr[arr.length] = 'dog'; // но этот способ не очень, есть получше - push
console.log(arr);


// также можно добавить элемент с любым индексом 

arr[10] = 'human';
console.log(arr);

// в таком случае у нас будет несколько индексов без элементов
// и тогда length - это не длина массива, а индекс последнего элемента + 1 


// массивы можно создавать и с помощью конструктора

let array = new Array(1, 2, 3); 
// если при создании массива таким способом передать в него аргументы, то они станут его элементами
// но если передать только один аргумент - он станет длиной массива!
console.log(array);

let arr2 = [1, 2, 3, 4];
arr2.length = 30; // можно вот так увеличить длину массива из которой 26 элементов будут пустыми 
console.log(arr2);
console.log('arr2.length', arr2.length);

// если length указть меньше, чем количество элементов в массиве, то тогда лишние элементы из массива будут удалены

// методы массивов 

let array2 = ['Apple', 'Orange', 'Banana'];

// метод push - добавляет в конец массива один или несколько элементов
// метод unshift - добавляет элемент в начало массива 

array2.push('Kiwi', 'Watermelon');
array2.unshift('Papaya', 'Mango');
console.log(array2);

// есть противоположные методы pop и shift - удаляющие из конца и начала массива соответсвенно 
// эти методы не принимают аргументы, они удаляют один элемент массива 

// если эти методы вызвать в консоль, то они выведут удаленный элемент 

array2.pop();
console.log(array2);

array2.shift();
console.log(array2);

// метод sort - сортирует массив по алфавиту и он обязательно учитывает регистр 
console.log(array2.sort());

// метод slice  
console.log(array2.slice(1, 3)); 
// возвращает массив начиная с заданного индекса включительно, по заданный элемент не включительно 
// метод slice не меняет массив, он возвращает новый 

// метод splice удаляет элементы и добавляет в массив новые 
// полностью метод описан в доке в obsidian 

// сам метод возвращает удаленные элементы 
console.log(array2.splice(1, 1, 'avocado', 'papaya'));
console.log(array2);

// метод join - возвращает нам строку 

console.log(array2.join(', ')); // возвращает строку, которая была сконкатенированна 

console.log(array2.reverse()); // разворачивает массив в обратную сторону, еще он изменяет текущий массив

// метод concat - складывает исходный массив с другим массивом или с другими элементами, но не изменяет текущий массив,
// а возвращает новый 

console.log(array2.concat(['watermelon', 'strawberry'], 'mango'));
// также можем отдельно через запятую добавить элемент mangо в массив 


// цикл for...in 

// название ключа не имеет значения, но обычно используется key
for (let key in car) {
   console.log('Ключ: ' + key + ' Значение: ' + car[key]);
}

// свойство length у объекта не существует, 
// чтоб получить количество значений 
console.log(Object.keys(car).length); // чтоб получить количество свойств в объекте 
// обращаемся к функции Object - это функция конструктор, далее к его методу keys(car) 
// и в круглых скобках указываем наш объект, после этого ставим точку и только тогда доавбляем length


// массив можно перебрать нескольким способами - обычным циклом for и другими 

for (let i = 0; i < array2.length; i++) {
   console.log(array2[i]);
}

// item - переменная, которой на каждой итерации цикла присваивается новое значение массива
// i - это индекс элемента 
// третьим аргументом можем передать сам массив, имя должно быть отличное, 
// чтобы не вызывало ошибку у старых браузеров, желательно не указывать такое же имя, как сам массив 

arr.forEach(function(item, i, array) {
   console.log(item, i, array);
});

// новый цикл, который появился в спецификации ES 2015
// это цикл for...of 
// он очень похож на цикл for...in, отличается только оператором, вместо in мы пишем of

// в этом цикле мы получаем элементы массива 
for (let item of arr) {
   console.log(item);
}


// почему нам не подходит цикл for...in

// если будем использовать этот цикл, то получим индексы вместо элементов 
for (let item in arr) {
   console.log(item);
}

// поэтому для работы с массивами цикл for...in не подойдет 

delete arr[3]; // удаляем элемент из массива по индексу
console.log('arr: ', arr);


// как удалять элементы из объекта 

let object = {
   a: 3,
   b: true,
   c: 'js'
};
delete object.b;
console.log(object);


// псевдомассивы - с ними можно столкнуться при работе с элементами на странице 
// псевдомассив - это объект, который похож на массив, 
// тоесть у него структура совпадает с массивами, есть нумерованные свойства и length, но методов массива у него нет  

// например в прошлом уроке мы изучили псевдомассив arguments - это список аргументов,
// которые мы передали во время вызова функции  


function test() {
   console.log(arguments);
}
test(1, 2, 3, 4);

// мы дальше будем получать элементы со страницы коллекциями и это будут псевдомассивы,
// с которыми нам необходимо будет работать и методы массивов на них не будут действовать 
