'use strict';


// 1. функции 

// функция - это набор команд, который пишется один раз и в дальнейшем его можно повторно использовать 
// желательно каждый законченный алгоритм заключать в функции, так становится легче читать программу и найти 
// необходимую часть, также его становится легко дебажить и тестировать   


// функцию можно объявить несколькими способами 

// 1-й способ создания - оператор function, после пишется: имя функции(парамерты) {тело функции}, 
// тело функции - это блок кода, который выполняется при вызове этой функции 

function firstMessage() {
   console.log('Hello world!');
}
firstMessage(); // вызов функции 

// создание функции при помощи ключевого слова function называется: function declaration - тоесть объявление 
// функции, ее особенность в том, что мы ее можем вызвать где угодно: после объявления либо до объявления. 
// имя функции должно быть глаголом - тоесть имя должно описывать то действие, которое выполняет функция


// 2-й способ создания - переменной присвоить функцию 

const consoleMessage = function() {
   console.log('Hello, friend!');
};
consoleMessage(); // вызывается функция также, как и первым способом 

// такое объявление функции называется function definition expression или сокращенно function expression, это 
// выражение определения функции, сокращенно - функциональное выражение 
// такую функцию можно вызывать только после ее объявления!
// если вызвать до - выдаст ошибку 


// также можно объявить функцию  с помощью конструктора 
// зададим переменную alertMessage, воспользуемся конструктором new Function и первым параметром в 
// конструкторе мы передаем тело функции, теперь в переменной alertMessage будет содержаться функция 

// const alertMessage = new Function('alert("Hi!")');
// alertMessage(); // вызываем функцию 

// такой спобоб с помощью конструктора очень редко используется, 
// есть также негласное правило: одна функция - одно действие, тоесть в функии не должно быть ничего, кроме 
// действия для которого она была создана 


// у функции есть параметры, которые можно в нее передавать (name, age)

function outputMessage(name, age) {
   console.log('Hello ' + name);
   console.log('My age: ' + age);
}
outputMessage('Alex', 20);
// при вызове функции в нее можно передать данные - аргументы функции ('Alex', 20)

// параметров и аргументов у функции может быть сколько угодно 


const sum1 = function(a, b) {
   let res = a + b;
   console.log(res);
};
sum1(5, 4);
// console.log(res); // выдаст ошибку, т.к. переменная объявлена внутри функции 


// объявляем переменную снаружи
let result  = 1;

const multiplication = function(x, y) {
   result = x * y;
};
// console.log(result); // 1 до вызова функции 
multiplication(5, 4);
console.log(result); // 20 


// чистая функция - это функция, которая полностью изолированна от остального кода, тоесть она может получать 
// аргументы и возвращать результат, она не влияет на переменные вне ее и снаружи на фунцию ничто не может 
// повлиять, кроме входных данных  

// к чистым функциям вернемся позже 


// функция имеет очень интересную возможность - она может возвращать какое-то значение на свое место 

const sum2 = function(c, d) {

   // присваиваем значения переменным, если не будут введены аргументы при вызове функции 
   if (c === undefined) {
      c = 0;
   }

   if (!d) { // тоже самое что и d === undefined
      d = 0;
   }

   console.log(arguments); // переменная arguments есть в каждой функции, позже мы рассмотрим более 
   // современный способ получения аргументов, и еще arguments это не массив, а псевдомассив 

   return c + d; // после return выполнение функции останавливается 
   // если не написать return, то тогда функция вернет значение undefined
};

let res2 = sum2(4, 7); // нам нужно вернуть значение из нашей функции 
console.log('res: ', res2);



// 2. анонимные, callback и чистые функции 

// 2.1 анонимные функции
// если после слова function есть имя, то она называется именнованная,
// во всех остальных случаях функция будет анонимной! 


// пример анонимной функции, мы эту функцию присваимваем переменной  
const sum = function(x) {
   x = Math.pow(x, 2);
   return x;
};

console.log(sum(5));

// еще пример анонимной функции 
const sum3 = new Function('a', 'b', 'return a + b'); // описываем входные данные и тело функции 

console.log(sum3()); // вызов функции
console.log(sum); // вывод функции в консоль
console.log(sum3); // вывод функции в консоль

// анонимная функция может иметь какое-то имя, если мы ее присваиваем переменной
// тоесть мы присваиваем анонимную функцию по ссылке в переменную
// наша функция будет храниться в памяти, не имея имени, но будет существовать переменная,
// которая ссылается на эту функцию    

// анонимные функции еще могут вызывать сами себя, но для этого надо их закрывать в скобки
// пример 

(function() {
   console.log('Hello');
}()); // чтобы вызвать функцию, ставим в конце скобки, либо после фигурных скобок  

(function() {
   console.log('Alex');
})(); // либо в самом конце 

// такой способ используется для инкапсуляции, когда мы хотим изолировать код от окружающих, 
// позже рассмотрим это подробнее  


// 2.2 callback функции 

// часто анонимные функции используют в качетсве callback функций 

// в качетсве параметров функции мы можем не только принимать какие-то переменные или какие-то значения, 
// но еще и функции, тоесть мы можем передать в качестве аргумента функцию - ее называют callback 
// и выполнять ее внутри нашей функции, в данном случае функции doNum 
// называют такие функции - функция обратного вызова и любая функция, которая передается как аргумент,
// называется функция обратного вызова(callback функция) // и она может быть анонимной 

// пример
const doNum = function(a, b, callback) {
   if(typeof a === 'number' && typeof b === 'number') {
      callback(a, b);
   }
};

doNum(5, 10, function(a, b){
   console.log(a + b);
});

// еще один пример
function mult (a, b) {
   console.log(a * b);
}

doNum(4, 5, mult);

// для чего нужны callback функции?
// например если у нас есть две функции 

/* function one() {
   // иммитация задержки
   setTimeout(function() {
      console.log('Получаем данные от сервера');
   }, 1000);
}

function two() {
   console.log('Выводим данные на страницу');
}

one();
two(); */

// из-за задержки первой функции javascript не дожидается ее ответа и выполняет следующую функцию,
// в результате чего нарушается порядок выполнения 

// решение проблемы 

function first(callback) {
   console.log('Делаем запрос на сервер');
   // иммитация задержки
   setTimeout(function() {
      console.log('Получаем данные от сервера');
      callback();
   }, 1000);
}

function second() {
   console.log('Выводим данные на страницу');
}

first(second);

// callback функции используются во время обработки события, то есть они вызываются, когда событие произошло,
// во время методов перебора, например foreach 

// главное запомнить, что callback функция всегда передается в другую функцию и выполняется после выполнения 
// первой функции 


// 2.3 чистые функции 

// Детерминированная функция зависит только от входных данных 

function foo(a, b) {
   const sum = a + b; // не изменяет входные данные 
   return sum; // возвращает результат 
}

console.log(foo(2, 3));

// в javascript существуют еще чистые функции, чистая функция должна быть детерминораванной,
// также чистая функция не должна иметь побочных эффектов, 
// тоесть эта функция не должна изменять входные данные и не должна изменять все, что находится
// вне этой функции 
// помимо того побочными эффектами еще являются, такие действия, как вывод в консоль, alert, 
// запись в файл, вывод на страницу и т.д. 

// тоесть функция должна получить только данные, сделать какие-то с этими данными операции 
// и выдать нам результат, причем не изменяя эти данные  

// например функция ниже не является чистой 

let x = 5;
console.log('x: ', x);

function func(a, b) {
   const sum = a + b;
   x += 5; // когда функция меняет переменную извне, она имеет побочный эффект => перестает быть чистой 
   console.log(sum); // тоже является побочным эффектом 
   // document.write(sum); // тоже является побочным эффектом  
   return sum; 
}

console.log(func(2, 3));
console.log('x: ', x);

// чистые функции очень похожи на математические 

// для чего нужны чистые функции?
// чистые функции проще в понимании и отладке, также в тестировании, 
// они не зависят от остального кода программы 
// и таким образом их можно вызывать в любое время, результат будет одинковый  

// чистые функции не зависят ни от чего, кроме входных данных  
