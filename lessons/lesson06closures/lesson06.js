'use strict';


// Область видимости - одна из самых фундаментальных тем javascript 

// поняв эту тему и замыкание, можно понять треть javascript

// Область видимости создается во время выполнения скрипта интерпретатором (браузером), 
// при объявлении переменной для нее создаются правила там где она будет доступна, 
// если переменная объявленна в теле программы - эта переменная будет доступна 
// в любой части программы, после ее объявления 

// без ключевого слова let у переменной будет глобальная область видимости даже внутри функции 
// так быть не должно, поэтому мы используем строгий режим и указаываем ключевое слово, 
// при определении перемнной 

let x = 5; // будет доступна везде, после ее объявления - у нее глобальная область видимости 
console.log('переменная x снаружи:', x);

let y = 4; // эта перемненная не имеет никакого отношения, к переменной y внутри функции 
console.log('переменная y снаружи:', y); // 4

function one(x, z) {
   // lexicalEnvironment = {x: 8, z: 3}
   let y = 10; // эта перемненная не имеет никакого отношения, к переменной снаружи
   // lexicalEnvironment = {x: 8, y: 10, z: 3}
   // если интерпретатор видит переменную в лексическом окружении, он берет ее значение 
   console.log('x:', x, 'y:', y, 'z:', z); // x: 8 y: 10 z: 3


   // let y = 10; // если эту переменную убрать, то тогда 
   // scope = globalScope = window.y = 4 // берет глобальную переменную y снаружи 
   // globalScope это объект window в браузере и все глобальные пременные содержатся в нем 
   // и тогда lexicalEnvironment = {x: 8, y: 4, z: 3}

   console.log('переменная y внутри функции:', y); // 10
   console.log('переменная x внутри функции:', x); // тут она тоже будет видна 

   function two() {
      // lexicalEnvironment = {}
      // в лексическом окружении мы не находим нужную переменную и тогда обращаемся к scope

      // scope - еще одно скрытое свойство, к которому может обращаться интерпретатор 
      // по сути scope - это ссылка на lexicalEnvironment родителя, в данном случае на function one()
      // scope = one.lexicalEnvironment = {x: 8, y: 10, z: 3}
      console.log('y из функции two:', y); // смотрит scope - находит там y и выводит его 
   }
   two();
}
one(8, 3);
// console.log(y); // снаружи ее не будет видно, выдаст ошибку


// в javascript область видимости определяется функциями, при создании функции 
// создается своя область видимости 

// если создать переменную внутри функции, то она видна и доступна только в этой функции, 
// это ее область видимости  


// область видимости определяет, какие переменные нам доступны, локальная область видимости создается
// при вызове функции, причем область видимости у каждого вызова функции будет своя, 
// даже если это одна функция  


// у функции есть скрытый объект lexicalEnvironment - лексическое окружение, 
// этот объект содержит значения всех локальных перемнных (тоесть объявенных внутри функции)
// но к сожалению к этому объекту нельзя обратиться 


// лексическое окружение определяется во время вызова функции, после передачи аргументов 
// а scope определяется во время создания функции, когда мы ее описываем 

function three(x) {
   console.log(x + y); // 3 + 4 
   // scope = globalScope = window.y = 4 
   // x = 3
   // y = 4 - 20 строчка y - глобальная переменная 
}

function four() {
   let y = 15;
   console.log(y);
   three(3); // хоть мы и вызвали эту функцию внутри другой, у переменной y берем ее глобальное значение 
}
four();



// замыкания 
// часто можно услышать, что замыкание - это функция внутри другой функции 

// замыкание - это функция со всеми ее переменными, которые ей доступны, тоесть все переменные, 
// которые функция может использовать находятся в замыкании с этой функцией 

// пример 

// если переменнная будет объявленна глобально 
let a = 20; 
// то она не будет замкнутой по отношению к функции 

function first() {
   // переменная x замкнута вместе с функцией second()
   let x = 10;

   function second(y) {
      // если переменная y была взята в качестве параметра, 
      // то переменную x взяли из функции родителя и эта переменная замкнута с функцией second()
      return x + y;
   }
   console.dir(second); // можем увидеть свойство scope, 
   // развернув его мы увидим свойство closure - замыкание 
   // [[Scopes]]: Scopes[3]
      // 0: Closure (first) {x: 10} // указано, что замыкание из функции (first)

   function third() {
      // эта функция не замкнута с функцией second() и никак не может с ней взаимодействовать 
      let y = 5;
      return x * y;
   }

   return second(15); // возвращает вызов функции 
}
console.log(first()); // 25 


// функция имеет замыкание с переменной a 
function funcMath() {
   const a = 10;
   // возвращаем анонимную функцию 
   return function() {
      console.log(a * a);
   };
}

const mathPow = funcMath();
mathPow();
console.dir(mathPow);

// эта функция имеет лексическое окружение в котором нет переменной a, 
// но она имеет ссылку на внешнее окружение в scope и получает доступ к родительскому окружению функции funcMath()
// это и есть замыкание 


// еще пример замыкания с параметром 

function funcMath2(a) {
   // возвращаем анонимную функцию 
   return function(b) {
      console.log(a * b);
   };
}

const mathPow2 = funcMath2(7);
mathPow2(5);
console.dir(mathPow2);


// итоги: 
// 1. после объявления переменной внутри функции доступ к ней возможен только в этой функции, 
// такие переменные называются определенными в контескте этой функции или локальные 

// 2. если объявлять функцию внутри другой функции, то внутренняя функция называется замыканием, 
// т.к. эта функция сохраняет доступ к переменным внешней функции 

